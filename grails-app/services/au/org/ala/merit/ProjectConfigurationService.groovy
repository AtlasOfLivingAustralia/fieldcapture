package au.org.ala.merit

import au.org.ala.merit.config.ProgramConfig
import groovy.util.logging.Slf4j

/**
 * The ProjectConfigurationService is responsible for obtaining the configuration used to present a project in MERIT.
 *
 * The configuration specifies things like the template used to render the project page, the type and frequency of
 * project reporting and how activity / report data entry behaves.
 *
 * It is mostly based on the program under which the project is being run.
 */
@Slf4j
class ProjectConfigurationService {

    ProgramService programService
    MetadataService metadataService
    ManagementUnitService managementUnitService

    ProgramConfig getProjectConfiguration(Map project) {
        ProgramConfig programConfig

        if (project.programId) {
            programConfig = buildConfigFromProgram(project)
        }
        else {
            programConfig = buildDefaultConfig(project)
        }

        programConfig.autogeneratedActivities = hasAutogeneratedActivities(programConfig)
        programConfig
    }

    private ProgramConfig buildConfigFromProgram(Map project) {
        Map program = programService.get(project.programId)
        Map rawProgramConfig = program.inheritedConfig ?: [:]
        Map projectConfig = project.config ?: [:]
        rawProgramConfig.putAll(projectConfig)
        ProgramConfig programConfig = new ProgramConfig(rawProgramConfig)

        if (!programConfig.activityBasedReporting) {

            List<Map> allServices = metadataService.getProjectServices()
            if (programConfig.programServiceConfig && programConfig.programServiceConfig.programServices) {
                programConfig.services = programConfig.programServiceConfig.programServices.collect { serviceConfig ->
                    Map service = allServices.find{it.id == serviceConfig.serviceId}
                    Map serviceFormSectionConfig = service.outputs?.find{ it.formName == programConfig.programServiceConfig.serviceFormName}
                    String output = serviceFormSectionConfig?.sectionName

                    List scores = service?.scores
                    // If the program configuration has specified a list of scores for the service, use those,
                    // otherwise use all possible scores that can be used by the service.
                    if (serviceConfig.serviceTargets) {
                        List primaryScores = scores?.findAll { it.scoreId in serviceConfig.serviceTargets }
                        primaryScores.each { Map score ->
                            score.relatedScores?.each { Map relatedScore ->
                                Map fullRelatedScore = scores.find { it.scoreId == relatedScore.scoreId }
                                relatedScore.score = fullRelatedScore
                            }
                        }
                        scores = primaryScores
                    }

                    // This allows programs to override the service name if required.  This is needed as the
                    // service names are listed in contracts so need to be kept the same for a program.
                    String serviceName = service.name
                    if (service?.programLabels && service.programLabels[project.programId]) {
                        serviceName = service.programLabels[project.programId].label ?: serviceName
                    }
                    [
                       id: service.id,
                       name: serviceName,
                       service: service,
                       output: output,
                       scores: scores,
                       mandatory: serviceConfig.mandatory
                    ]
                }
            }
            else {
                programConfig.services = allServices.collect { Map service ->
                    [id: service.id,
                     name: service.name,
                     service: service,
                     output:null,
                     scores: service.scores
                    ]
                }
            }
        }
        // Outcomes are defined by the program (optionally replaced by the project)
        programConfig.outcomes = projectConfig.outcomes ?: (program.outcomes ?: [])

        programConfig.priorities = getInvestmentPrioritiesForOutcomes( programConfig.outcomes) ?: []
        programConfig.themes = program.themes ?: []
        programConfig.program = program

        // The project configuration is mostly derived from the program it is run
        // under, but if it is delivered by the management unit arrangement, some
        // some of the configuration can be supplied by the management unit.
        if (project.managementUnitId) {
            Map managementUnit = managementUnitService.get(project.managementUnitId)
            Map config = managementUnit.config
            programConfig.priorities = projectConfig.priorities.findAll{!it.managementUnits || project.managementUnitId in it.managementUnits}

            // There may be only a subset of the program assets/priorities that
            // actually exist within the boundary of the management unit.
            // (e.g. threatened species may be known to exist within some
            // management units but not others)
            programConfig.priorities = programConfig.priorities.findAll{
                !it.managementUnits || it.managementUnits?.contains(project.managementUnitId)
            }

            // If the program doesn't define outcomes, use ones for the management unit.
            if (!programConfig.outcomes && managementUnit.outcomes) {
                programConfig.outcomes = managementUnit.outcomes
            }

            // Allow management units to override project reporting frequency
            if (!programConfig.projectReports) {
                programConfig.projectReports = []
            }
            if (!projectConfig.projectReports) {
                config.projectReports?.each { Map configuration ->
                    Map projectReport = programConfig.projectReports?.find {
                        return it.category == configuration.category && it.activityType == configuration.activityType
                    }
                    if (projectReport) {
                        // Both the frequency and start date are required so the report dates
                        // align correctly.
                        if (configuration.reportingPeriodInMonths) {
                            projectReport.reportingPeriodInMonths = configuration.reportingPeriodInMonths
                        }
                        if (configuration.firstReportingPeriodEnd) {
                            projectReport.firstReportingPeriodEnd = configuration.firstReportingPeriodEnd
                        }
                        // RLP projects label 3 monthly reports as "Quarter" and 6 monthly reports as "Semester"
                        // to simplify downstream reporting.
                        if (configuration.label) {
                            projectReport.label = configuration.label
                        }
                    }
                }
            }
        }
        programConfig
    }

    /**
     * This creates a configuration from the legacy MERIT programsModel.
     */
    private ProgramConfig buildDefaultConfig(Map project) {
        Map config = metadataService.getProgramConfiguration(project.associatedProgram, project.associatedSubProgram)
        ProgramConfig programConfig = new ProgramConfig(config)
        programConfig.activityBasedReporting = true

        // Default configuration for project stage reports.

        Integer reportingPeriodInMonths = 6 // Default period
        try {
            reportingPeriodInMonths = Integer.parseInt(programConfig.reportingPeriod)
        }
        catch (Exception e) {
            log.warn("Invalid period specified in program: "+programConfig.reportingPeriod)
        }

        programConfig.projectReports = [
                [
                        weekDaysToCompleteReport:programConfig.weekDaysToCompleteReport,
                        reportType:ReportService.REPORT_TYPE_STAGE_REPORT,
                        reportingPeriodInMonths: reportingPeriodInMonths,
                        reportsAlignedToCalendar: Boolean.valueOf(programConfig.reportingPeriodAlignedToCalendar),
                        reportNameFormat: "Stage %1d",
                        reportDescriptionFormat: "Stage %1d for ${project.name}"
                ]
        ]
        // The original MERIT project template required content be included (excluded by default) but we've
        // moved to an included by default model.
        programConfig.excludes = [ProgramConfig.ProjectContent.DATA_SETS.toString(), ProgramConfig.ProjectContent.MERI_PLAN.toString(), ProgramConfig.ProjectContent.RISKS_AND_THREATS.toString()]
        Map mapping = [
                'MERI Plan':  ProgramConfig.ProjectContent.MERI_PLAN.toString(),
                'Risks and Threats': ProgramConfig.ProjectContent.RISKS_AND_THREATS.toString()
        ]

        config.optionalProjectContent?.each { String content ->
            programConfig.excludes.remove(mapping[content])
        }

        programConfig.activities = config.activities
        programConfig
    }

    /**
     * A configuration consists of autogenerated activities if every report configuration specifies an activityType.
     * (Specifying an activity type will result in an activity being auto-generated for each report type).
     * @param config the project configuration to check.
     */
    private boolean hasAutogeneratedActivities(Map config) {

        boolean autogeneratedActivities = false
        if (config.projectReports) {
            autogeneratedActivities = config.projectReports.every{it.activityType != null}
        }

        autogeneratedActivities
    }


    private List<Map> getInvestmentPrioritiesForOutcomes(List outcomes) {
        List categories = outcomes.collect{ it.priorities?.collect{it.category} }
        categories = categories.flatten().unique()

        metadataService.findInvestmentPrioritiesByCategory(categories)

    }
}
